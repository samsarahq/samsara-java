/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.samsara.api.resources.routes.requests;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.samsara.api.core.ObjectMappers;
import com.samsara.api.types.RouteSettingsRequestBody;
import com.samsara.api.types.UpdateRoutesStopRequestObjectRequestBody;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = RoutesPatchRouteRequestBody.Builder.class)
public final class RoutesPatchRouteRequestBody {
    private final Optional<String> driverId;

    private final Optional<Map<String, String>> externalIds;

    private final Optional<String> name;

    private final Optional<String> notes;

    private final Optional<Boolean> recomputeScheduledTimes;

    private final Optional<RouteSettingsRequestBody> settings;

    private final Optional<List<UpdateRoutesStopRequestObjectRequestBody>> stops;

    private final Optional<List<String>> tagIds;

    private final Optional<String> vehicleId;

    private final Map<String, Object> additionalProperties;

    private RoutesPatchRouteRequestBody(
            Optional<String> driverId,
            Optional<Map<String, String>> externalIds,
            Optional<String> name,
            Optional<String> notes,
            Optional<Boolean> recomputeScheduledTimes,
            Optional<RouteSettingsRequestBody> settings,
            Optional<List<UpdateRoutesStopRequestObjectRequestBody>> stops,
            Optional<List<String>> tagIds,
            Optional<String> vehicleId,
            Map<String, Object> additionalProperties) {
        this.driverId = driverId;
        this.externalIds = externalIds;
        this.name = name;
        this.notes = notes;
        this.recomputeScheduledTimes = recomputeScheduledTimes;
        this.settings = settings;
        this.stops = stops;
        this.tagIds = tagIds;
        this.vehicleId = vehicleId;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return ID of the driver. Can be either a unique Samsara ID or an <a href="https://developers.samsara.com/docs/external-ids">external ID</a> for the driver.
     */
    @JsonProperty("driverId")
    public Optional<String> getDriverId() {
        return driverId;
    }

    /**
     * @return A map of external ids
     */
    @JsonProperty("externalIds")
    public Optional<Map<String, String>> getExternalIds() {
        return externalIds;
    }

    /**
     * @return Name for the route
     */
    @JsonProperty("name")
    public Optional<String> getName() {
        return name;
    }

    /**
     * @return Notes about the route.
     */
    @JsonProperty("notes")
    public Optional<String> getNotes() {
        return notes;
    }

    /**
     * @return This optional boolean parameter controls whether route schedule arrival and departure times are recalculated. When set to true, the system will automatically recompute the scheduledArrivalTime and scheduledDepartureTime for each stop along the route during route creation. This process overrides any manually provided values, with the exception of the first stop, which retains its user-defined schedule.
     */
    @JsonProperty("recomputeScheduledTimes")
    public Optional<Boolean> getRecomputeScheduledTimes() {
        return recomputeScheduledTimes;
    }

    @JsonProperty("settings")
    public Optional<RouteSettingsRequestBody> getSettings() {
        return settings;
    }

    /**
     * @return List of stops along the route. If a valid <code>id</code> of a stop is provided, that stop will be updated. If no <code>id</code> is provided for a passed in stop, that stop will be created. If <code>id</code> value are passed in for some stops and not for others, those with <code>id</code> value specified will be retained and updated in the original route, those without <code>id</code> value specified in the body will be created, and those without <code>id</code> value specified that already existed on the route will be deleted. For each new stop, exactly one of <code>addressId</code> and <code>singleUseLocation</code> are required. Depending on the <code>settings</code> on your route, either a <code>scheduledArrivalTime</code> or <code>scheduledDepartureTime</code> must be specified for the first job, if a new first job is being added.
     */
    @JsonProperty("stops")
    public Optional<List<UpdateRoutesStopRequestObjectRequestBody>> getStops() {
        return stops;
    }

    /**
     * @return An array of IDs of tags to associate with this route.
     */
    @JsonProperty("tagIds")
    public Optional<List<String>> getTagIds() {
        return tagIds;
    }

    /**
     * @return ID of the vehicle. Can be either a unique Samsara ID or an <a href="https://developers.samsara.com/docs/external-ids">external ID</a> for the vehicle.
     */
    @JsonProperty("vehicleId")
    public Optional<String> getVehicleId() {
        return vehicleId;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof RoutesPatchRouteRequestBody && equalTo((RoutesPatchRouteRequestBody) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(RoutesPatchRouteRequestBody other) {
        return driverId.equals(other.driverId)
                && externalIds.equals(other.externalIds)
                && name.equals(other.name)
                && notes.equals(other.notes)
                && recomputeScheduledTimes.equals(other.recomputeScheduledTimes)
                && settings.equals(other.settings)
                && stops.equals(other.stops)
                && tagIds.equals(other.tagIds)
                && vehicleId.equals(other.vehicleId);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.driverId,
                this.externalIds,
                this.name,
                this.notes,
                this.recomputeScheduledTimes,
                this.settings,
                this.stops,
                this.tagIds,
                this.vehicleId);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<String> driverId = Optional.empty();

        private Optional<Map<String, String>> externalIds = Optional.empty();

        private Optional<String> name = Optional.empty();

        private Optional<String> notes = Optional.empty();

        private Optional<Boolean> recomputeScheduledTimes = Optional.empty();

        private Optional<RouteSettingsRequestBody> settings = Optional.empty();

        private Optional<List<UpdateRoutesStopRequestObjectRequestBody>> stops = Optional.empty();

        private Optional<List<String>> tagIds = Optional.empty();

        private Optional<String> vehicleId = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(RoutesPatchRouteRequestBody other) {
            driverId(other.getDriverId());
            externalIds(other.getExternalIds());
            name(other.getName());
            notes(other.getNotes());
            recomputeScheduledTimes(other.getRecomputeScheduledTimes());
            settings(other.getSettings());
            stops(other.getStops());
            tagIds(other.getTagIds());
            vehicleId(other.getVehicleId());
            return this;
        }

        /**
         * <p>ID of the driver. Can be either a unique Samsara ID or an <a href="https://developers.samsara.com/docs/external-ids">external ID</a> for the driver.</p>
         */
        @JsonSetter(value = "driverId", nulls = Nulls.SKIP)
        public Builder driverId(Optional<String> driverId) {
            this.driverId = driverId;
            return this;
        }

        public Builder driverId(String driverId) {
            this.driverId = Optional.ofNullable(driverId);
            return this;
        }

        /**
         * <p>A map of external ids</p>
         */
        @JsonSetter(value = "externalIds", nulls = Nulls.SKIP)
        public Builder externalIds(Optional<Map<String, String>> externalIds) {
            this.externalIds = externalIds;
            return this;
        }

        public Builder externalIds(Map<String, String> externalIds) {
            this.externalIds = Optional.ofNullable(externalIds);
            return this;
        }

        /**
         * <p>Name for the route</p>
         */
        @JsonSetter(value = "name", nulls = Nulls.SKIP)
        public Builder name(Optional<String> name) {
            this.name = name;
            return this;
        }

        public Builder name(String name) {
            this.name = Optional.ofNullable(name);
            return this;
        }

        /**
         * <p>Notes about the route.</p>
         */
        @JsonSetter(value = "notes", nulls = Nulls.SKIP)
        public Builder notes(Optional<String> notes) {
            this.notes = notes;
            return this;
        }

        public Builder notes(String notes) {
            this.notes = Optional.ofNullable(notes);
            return this;
        }

        /**
         * <p>This optional boolean parameter controls whether route schedule arrival and departure times are recalculated. When set to true, the system will automatically recompute the scheduledArrivalTime and scheduledDepartureTime for each stop along the route during route creation. This process overrides any manually provided values, with the exception of the first stop, which retains its user-defined schedule.</p>
         */
        @JsonSetter(value = "recomputeScheduledTimes", nulls = Nulls.SKIP)
        public Builder recomputeScheduledTimes(Optional<Boolean> recomputeScheduledTimes) {
            this.recomputeScheduledTimes = recomputeScheduledTimes;
            return this;
        }

        public Builder recomputeScheduledTimes(Boolean recomputeScheduledTimes) {
            this.recomputeScheduledTimes = Optional.ofNullable(recomputeScheduledTimes);
            return this;
        }

        @JsonSetter(value = "settings", nulls = Nulls.SKIP)
        public Builder settings(Optional<RouteSettingsRequestBody> settings) {
            this.settings = settings;
            return this;
        }

        public Builder settings(RouteSettingsRequestBody settings) {
            this.settings = Optional.ofNullable(settings);
            return this;
        }

        /**
         * <p>List of stops along the route. If a valid <code>id</code> of a stop is provided, that stop will be updated. If no <code>id</code> is provided for a passed in stop, that stop will be created. If <code>id</code> value are passed in for some stops and not for others, those with <code>id</code> value specified will be retained and updated in the original route, those without <code>id</code> value specified in the body will be created, and those without <code>id</code> value specified that already existed on the route will be deleted. For each new stop, exactly one of <code>addressId</code> and <code>singleUseLocation</code> are required. Depending on the <code>settings</code> on your route, either a <code>scheduledArrivalTime</code> or <code>scheduledDepartureTime</code> must be specified for the first job, if a new first job is being added.</p>
         */
        @JsonSetter(value = "stops", nulls = Nulls.SKIP)
        public Builder stops(Optional<List<UpdateRoutesStopRequestObjectRequestBody>> stops) {
            this.stops = stops;
            return this;
        }

        public Builder stops(List<UpdateRoutesStopRequestObjectRequestBody> stops) {
            this.stops = Optional.ofNullable(stops);
            return this;
        }

        /**
         * <p>An array of IDs of tags to associate with this route.</p>
         */
        @JsonSetter(value = "tagIds", nulls = Nulls.SKIP)
        public Builder tagIds(Optional<List<String>> tagIds) {
            this.tagIds = tagIds;
            return this;
        }

        public Builder tagIds(List<String> tagIds) {
            this.tagIds = Optional.ofNullable(tagIds);
            return this;
        }

        /**
         * <p>ID of the vehicle. Can be either a unique Samsara ID or an <a href="https://developers.samsara.com/docs/external-ids">external ID</a> for the vehicle.</p>
         */
        @JsonSetter(value = "vehicleId", nulls = Nulls.SKIP)
        public Builder vehicleId(Optional<String> vehicleId) {
            this.vehicleId = vehicleId;
            return this;
        }

        public Builder vehicleId(String vehicleId) {
            this.vehicleId = Optional.ofNullable(vehicleId);
            return this;
        }

        public RoutesPatchRouteRequestBody build() {
            return new RoutesPatchRouteRequestBody(
                    driverId,
                    externalIds,
                    name,
                    notes,
                    recomputeScheduledTimes,
                    settings,
                    stops,
                    tagIds,
                    vehicleId,
                    additionalProperties);
        }
    }
}
