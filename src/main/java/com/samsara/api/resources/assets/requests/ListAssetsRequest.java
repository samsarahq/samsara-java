/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.samsara.api.resources.assets.requests;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.samsara.api.core.ObjectMappers;
import com.samsara.api.resources.assets.types.ListAssetsRequestType;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ListAssetsRequest.Builder.class)
public final class ListAssetsRequest {
    private final Optional<List<String>> ids;

    private final Optional<List<String>> attributes;

    private final Optional<ListAssetsRequestType> type;

    private final Optional<String> after;

    private final Optional<String> updatedAfterTime;

    private final Optional<Boolean> includeExternalIds;

    private final Optional<Boolean> includeTags;

    private final Optional<String> tagIds;

    private final Optional<String> parentTagIds;

    private final Optional<String> attributeValueIds;

    private final Map<String, Object> additionalProperties;

    private ListAssetsRequest(
            Optional<List<String>> ids,
            Optional<List<String>> attributes,
            Optional<ListAssetsRequestType> type,
            Optional<String> after,
            Optional<String> updatedAfterTime,
            Optional<Boolean> includeExternalIds,
            Optional<Boolean> includeTags,
            Optional<String> tagIds,
            Optional<String> parentTagIds,
            Optional<String> attributeValueIds,
            Map<String, Object> additionalProperties) {
        this.ids = ids;
        this.attributes = attributes;
        this.type = type;
        this.after = after;
        this.updatedAfterTime = updatedAfterTime;
        this.includeExternalIds = includeExternalIds;
        this.includeTags = includeTags;
        this.tagIds = tagIds;
        this.parentTagIds = parentTagIds;
        this.attributeValueIds = attributeValueIds;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return A filter on the data based on this comma-separated list of asset IDs and External IDs.
     */
    @JsonProperty("ids")
    public Optional<List<String>> getIds() {
        return ids;
    }

    /**
     * @return A filter on the data to return entities within given range query (only for numeric attributes) separated by a comma. Only entities meeting all the conditions will be returned. At least one bound must be provided. Example: <code>attributes=Length:range(8,)&amp;attributes=Length:range(10,20)</code>
     */
    @JsonProperty("attributes")
    public Optional<List<String>> getAttributes() {
        return attributes;
    }

    /**
     * @return The operational context in which the asset interacts with the Samsara system. Examples: Vehicle (eg: truck, bus...), Trailer (eg: dry van, reefer, flatbed...), Powered Equipment (eg: dozer, crane...), Unpowered Equipment (eg: container, dumpster...), or Uncategorized.  Valid values: <code>uncategorized</code>, <code>trailer</code>, <code>equipment</code>, <code>unpowered</code>, <code>vehicle</code>
     */
    @JsonProperty("type")
    public Optional<ListAssetsRequestType> getType() {
        return type;
    }

    /**
     * @return If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
     */
    @JsonProperty("after")
    public Optional<String> getAfter() {
        return after;
    }

    /**
     * @return A filter on data to have an updated at time after or equal to this specified time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
     */
    @JsonProperty("updatedAfterTime")
    public Optional<String> getUpdatedAfterTime() {
        return updatedAfterTime;
    }

    /**
     * @return Optional boolean indicating whether to return external IDs on supported entities
     */
    @JsonProperty("includeExternalIds")
    public Optional<Boolean> getIncludeExternalIds() {
        return includeExternalIds;
    }

    /**
     * @return Optional boolean indicating whether to return tags on supported entities
     */
    @JsonProperty("includeTags")
    public Optional<Boolean> getIncludeTags() {
        return includeTags;
    }

    /**
     * @return A filter on the data based on this comma-separated list of tag IDs. Example: <code>tagIds=1234,5678</code>
     */
    @JsonProperty("tagIds")
    public Optional<String> getTagIds() {
        return tagIds;
    }

    /**
     * @return A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: <code>parentTagIds=345,678</code>
     */
    @JsonProperty("parentTagIds")
    public Optional<String> getParentTagIds() {
        return parentTagIds;
    }

    /**
     * @return A filter on the data based on this comma-separated list of attribute value IDs. Only entities associated with ALL of the referenced values will be returned (i.e. the intersection of the sets of entities with each value). Example: <code>attributeValueIds=076efac2-83b5-47aa-ba36-18428436dcac,6707b3f0-23b9-4fe3-b7be-11be34aea544</code>
     */
    @JsonProperty("attributeValueIds")
    public Optional<String> getAttributeValueIds() {
        return attributeValueIds;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ListAssetsRequest && equalTo((ListAssetsRequest) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ListAssetsRequest other) {
        return ids.equals(other.ids)
                && attributes.equals(other.attributes)
                && type.equals(other.type)
                && after.equals(other.after)
                && updatedAfterTime.equals(other.updatedAfterTime)
                && includeExternalIds.equals(other.includeExternalIds)
                && includeTags.equals(other.includeTags)
                && tagIds.equals(other.tagIds)
                && parentTagIds.equals(other.parentTagIds)
                && attributeValueIds.equals(other.attributeValueIds);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.ids,
                this.attributes,
                this.type,
                this.after,
                this.updatedAfterTime,
                this.includeExternalIds,
                this.includeTags,
                this.tagIds,
                this.parentTagIds,
                this.attributeValueIds);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<List<String>> ids = Optional.empty();

        private Optional<List<String>> attributes = Optional.empty();

        private Optional<ListAssetsRequestType> type = Optional.empty();

        private Optional<String> after = Optional.empty();

        private Optional<String> updatedAfterTime = Optional.empty();

        private Optional<Boolean> includeExternalIds = Optional.empty();

        private Optional<Boolean> includeTags = Optional.empty();

        private Optional<String> tagIds = Optional.empty();

        private Optional<String> parentTagIds = Optional.empty();

        private Optional<String> attributeValueIds = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(ListAssetsRequest other) {
            ids(other.getIds());
            attributes(other.getAttributes());
            type(other.getType());
            after(other.getAfter());
            updatedAfterTime(other.getUpdatedAfterTime());
            includeExternalIds(other.getIncludeExternalIds());
            includeTags(other.getIncludeTags());
            tagIds(other.getTagIds());
            parentTagIds(other.getParentTagIds());
            attributeValueIds(other.getAttributeValueIds());
            return this;
        }

        /**
         * <p>A filter on the data based on this comma-separated list of asset IDs and External IDs.</p>
         */
        @JsonSetter(value = "ids", nulls = Nulls.SKIP)
        public Builder ids(Optional<List<String>> ids) {
            this.ids = ids;
            return this;
        }

        public Builder ids(List<String> ids) {
            this.ids = Optional.ofNullable(ids);
            return this;
        }

        public Builder ids(String ids) {
            this.ids = Optional.of(Collections.singletonList(ids));
            return this;
        }

        /**
         * <p>A filter on the data to return entities within given range query (only for numeric attributes) separated by a comma. Only entities meeting all the conditions will be returned. At least one bound must be provided. Example: <code>attributes=Length:range(8,)&amp;attributes=Length:range(10,20)</code></p>
         */
        @JsonSetter(value = "attributes", nulls = Nulls.SKIP)
        public Builder attributes(Optional<List<String>> attributes) {
            this.attributes = attributes;
            return this;
        }

        public Builder attributes(List<String> attributes) {
            this.attributes = Optional.ofNullable(attributes);
            return this;
        }

        public Builder attributes(String attributes) {
            this.attributes = Optional.of(Collections.singletonList(attributes));
            return this;
        }

        /**
         * <p>The operational context in which the asset interacts with the Samsara system. Examples: Vehicle (eg: truck, bus...), Trailer (eg: dry van, reefer, flatbed...), Powered Equipment (eg: dozer, crane...), Unpowered Equipment (eg: container, dumpster...), or Uncategorized.  Valid values: <code>uncategorized</code>, <code>trailer</code>, <code>equipment</code>, <code>unpowered</code>, <code>vehicle</code></p>
         */
        @JsonSetter(value = "type", nulls = Nulls.SKIP)
        public Builder type(Optional<ListAssetsRequestType> type) {
            this.type = type;
            return this;
        }

        public Builder type(ListAssetsRequestType type) {
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * <p>If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.</p>
         */
        @JsonSetter(value = "after", nulls = Nulls.SKIP)
        public Builder after(Optional<String> after) {
            this.after = after;
            return this;
        }

        public Builder after(String after) {
            this.after = Optional.ofNullable(after);
            return this;
        }

        /**
         * <p>A filter on data to have an updated at time after or equal to this specified time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).</p>
         */
        @JsonSetter(value = "updatedAfterTime", nulls = Nulls.SKIP)
        public Builder updatedAfterTime(Optional<String> updatedAfterTime) {
            this.updatedAfterTime = updatedAfterTime;
            return this;
        }

        public Builder updatedAfterTime(String updatedAfterTime) {
            this.updatedAfterTime = Optional.ofNullable(updatedAfterTime);
            return this;
        }

        /**
         * <p>Optional boolean indicating whether to return external IDs on supported entities</p>
         */
        @JsonSetter(value = "includeExternalIds", nulls = Nulls.SKIP)
        public Builder includeExternalIds(Optional<Boolean> includeExternalIds) {
            this.includeExternalIds = includeExternalIds;
            return this;
        }

        public Builder includeExternalIds(Boolean includeExternalIds) {
            this.includeExternalIds = Optional.ofNullable(includeExternalIds);
            return this;
        }

        /**
         * <p>Optional boolean indicating whether to return tags on supported entities</p>
         */
        @JsonSetter(value = "includeTags", nulls = Nulls.SKIP)
        public Builder includeTags(Optional<Boolean> includeTags) {
            this.includeTags = includeTags;
            return this;
        }

        public Builder includeTags(Boolean includeTags) {
            this.includeTags = Optional.ofNullable(includeTags);
            return this;
        }

        /**
         * <p>A filter on the data based on this comma-separated list of tag IDs. Example: <code>tagIds=1234,5678</code></p>
         */
        @JsonSetter(value = "tagIds", nulls = Nulls.SKIP)
        public Builder tagIds(Optional<String> tagIds) {
            this.tagIds = tagIds;
            return this;
        }

        public Builder tagIds(String tagIds) {
            this.tagIds = Optional.ofNullable(tagIds);
            return this;
        }

        /**
         * <p>A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: <code>parentTagIds=345,678</code></p>
         */
        @JsonSetter(value = "parentTagIds", nulls = Nulls.SKIP)
        public Builder parentTagIds(Optional<String> parentTagIds) {
            this.parentTagIds = parentTagIds;
            return this;
        }

        public Builder parentTagIds(String parentTagIds) {
            this.parentTagIds = Optional.ofNullable(parentTagIds);
            return this;
        }

        /**
         * <p>A filter on the data based on this comma-separated list of attribute value IDs. Only entities associated with ALL of the referenced values will be returned (i.e. the intersection of the sets of entities with each value). Example: <code>attributeValueIds=076efac2-83b5-47aa-ba36-18428436dcac,6707b3f0-23b9-4fe3-b7be-11be34aea544</code></p>
         */
        @JsonSetter(value = "attributeValueIds", nulls = Nulls.SKIP)
        public Builder attributeValueIds(Optional<String> attributeValueIds) {
            this.attributeValueIds = attributeValueIds;
            return this;
        }

        public Builder attributeValueIds(String attributeValueIds) {
            this.attributeValueIds = Optional.ofNullable(attributeValueIds);
            return this;
        }

        public ListAssetsRequest build() {
            return new ListAssetsRequest(
                    ids,
                    attributes,
                    type,
                    after,
                    updatedAfterTime,
                    includeExternalIds,
                    includeTags,
                    tagIds,
                    parentTagIds,
                    attributeValueIds,
                    additionalProperties);
        }
    }
}
